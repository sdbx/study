# 3.7 요약
3장은 브랜치를 조명하는 장이었다.
이 장을 읽고 브랜치에 대해 몰랐던 여러가지 사실들을 알았다.

## 3장 1절
브랜치에 대한 기본 개념을 다루는 절이다.

- 브랜칭 = 주된 개발 흐름에서 분기하여 별도로 작업하는 것
- 브랜치 = 비유하자면 커밋을 가리키는 화살표. 실제로는 자신이 가리키고 있는 커밋의 해시값(40자리 SHA-1 체크섬)을 가지고 있는 파일이다.
- 커밋을 할 때마다 브랜치는 자동적으로 앞으로 이동함 (새로 만든 커밋을 가리킴)
- HEAD는 특별한 포인터로, 현재 내가 위치한 브랜치를 가리키고 있음.
- 브랜치가 무슨 커밋을 가리키고 있는지 궁금하다 => `git log --decorate`
- 브랜치를 만들고 싶다 => `git branch <br_name>`
- 브랜치를 전환하고 싶다 (작업영역도 변경됨) => `git checkout <br_name>`
- 브랜치를 만듦과 동시에 전환 => `git checkout -b <br_name>`
- 깃 버전 2.23에 새로 나온 명령어인 `git switch` 는 `git branch` 를 대체 가능
   - `git switch -c <br_name>` => 브랜치 생성과 동시에 전환
   - `git switch -` => 이전에 체크아웃했던 브랜치로 이동

## 3장 2절
병합에 대해 설명하는 절이다.

- `git switch <merge_into>` => 먼저 병합을 받고자 하는 브랜치로 이동
- `git merge <merge_in>` => 병합하려는 브랜치를 작성
- fast-forward란 분기된 이력이 없어서 단순히 브랜치가 앞으로 이동되었다는 뜻이다.
- three-way merge란 분기된 두 브랜치의 공통 조상과 각 브랜치의 끝에 있는 커밋을 사용하는 병합이다.
   - 그 결과로 새로운 스냅샷과 그 스냅샷을 가리키는 커밋이 생성된다.
   - 이 커밋을 **merge commit** 이라고 한다.
- 병합 간에, 두 커밋이 같은 파일의 같은 내용을 변경했을 경우 충돌이 일어난다.
   - `git status` 를 통해 충돌이 난 파일을 확인가능하다.
   - 해당 파일을 열어서 충돌을 해결하고 `git add <filename>` 으로 충돌이 해결되었음을 표시한다.
   - 모든 충돌을 해결했을 경우 `git commit` 을 통해 병합을 완료한다.

## 3장 3절
브랜치 관리 기법에 다루는 절이다.

- `git branch --verbose` => 브랜치가 가리키는 커밋도 같이 출력해줘
- `git branch --all` => 로컬브랜치와 원추브랜치를 모두 열거해줘
- `git branch --merged [<br_name>]` => 현재 위치한 브랜치에 (혹은 br_name 브랜치에) 병합된 브랜치를 출력해줘
- `git branch --move <oldname> <newname>` => 로컬 브랜치명 변경
- `git push --set-upstream <remote> <newname>` => 변경된 브랜치를 서버에 전송
- `git push <remote> --delete <oldname>` => 서버에서 이전에 사용하던 브랜치명 제거
- master/main/mainline/default와 같은 브랜치명을 함부로 바꾸는 것은 지양하라.

## 3장 4절
브랜치를 사용한 작업흐름에 대해 다루는 절이다.

- master 브랜치, develop 브랜치, topic 브랜치로 브랜치의 "급"을 구분한다.
- 하급 브랜치가 승급할 정도가 되면 상급 브랜치로 병합되는 방식이다.
- master 브랜치와 develop 브랜치는 장기적으로 존재하나 topic은 일시적으로 존재.
- 이 작업 흐름 모델은 프로젝트의 규모가 큰 경우 때때로 유용함.
- topic 브랜치만을 사용하는 모델은 프로젝트의 규모에 상관없이 유용.
- 개별 작업을 별도의 브랜치에서 관리하므로, 작업 간 맥락 전환이 자유롭다.

## 3장 5절
원추브랜치에 대해 설명하는 중요한 절이다.

- 원격 레퍼런스란 서버에 있는 레퍼런스(=포인터)로, 브랜치나 태그 등을 말한다.
- 원추브랜치란 **원격 브랜치의 상태**에 대한 레퍼런스를 말한다.
   - 원추브랜치는 로컬 레퍼런스이며 내가 직접 움직일 수 없다.
   - 서버와 통신이 있을 때마다 git이 알아서 관리한다.
   - 마지막에 서버와 통신했을 때 **원격 브랜치가 어디 있었는지**를 나타낸다.
   - 원추브랜치의 이름은 `<remote>/<branch>` 의 형식을 가진다.
   - 원추브랜치의 내용을 로컬 브랜치에 합치려면 `git merge <remote>/<branch>` 해야 한다.
   - 원추브랜치가 있는 곳에 내가 작업하기 위한 로컬브랜치를 만드려면 `git checkout -b <local_branch_name> <remote>/<remote_branch_name>` 해야 한다. (이러면 해당 로컬브랜치는 자동적으로 추적브랜치가 됨. 자세한 것은 바로 아래에 후술.)
- `git fetch <remote>` 를 하면 로컬에는 아직 없는 데이터를 가져옴으로써 로컬이 서버와 동기화된다. 로컬 데이터베이스가 갱신되고 원추브랜치의 위치가 갱신된다.
- `git push <remote> <local_branch>:<remote_branch>` => 로컬에 있는 브랜치로 원격에 있는 브랜치를 갱신하라는 뜻이다.
- 추적한다는 말의 뜻은 `git pull` 을 했을 때 git이 어떤 서버에서 fetch할지, 어떤 브랜치를 merge해야 하는지를 알고 있다는 뜻이다.
   - 추적 브랜치 = 관련있는 원추브랜치가 지정된 브랜치
   - 추적 브랜치가 추적하는 원추브랜치를 업스트림 브랜치라고 하는 것 같다.
   - 로컬 브랜치가 원추브랜치를 추적하게 해줘 => `git branch -u <remote>/<branch>`
   - 업스트림 브랜치를 `@{u}` 라고 지칭가능하다.
   - `git branch -vv` => 추적브랜치를 보여줘
- ahead = 서버에 아직 push되지 않은 커밋이 로컬에 있다. (마지막으로 통신한 시점 기준)
- behind = 서버에 아직 로컬에 병합되지 않은 커밋이 있다.
- `git pull` 은 대부분의 경우 `git fetch` 에 뒤따르는 `git merge` 와 같음.

## 3장 6절
리베이스에 다루는 중요한 절이다.

- rebase란 merge처럼 한 브랜치에 있는 내용을 다른 브랜치에 통합하는 명령어이나, 통합하는 방식에 차이가 있다.
- merge는 머지커밋이 생길 수 있으나 rebase는 커밋 자체가 이동된다.
- 구문 => `git rebase [--onto <newbase>] [<upsteram [<branch>]]`
- 위 명령어의 뜻 = branch에는 있는데 upstream에는 없는 커밋들을 upstream 혹은 newbase 뒤에 붙여라.
- rebase할 때 주의할 점: 서버에 이미 존재하는 커밋을 리베이스하거나, 사람들이 이미 작업에 사용한 커밋을 리베이스하면 안된다. (커밋 이력이 지저분해지기 때문이다.)
   - 만약 이런 일이 발생한 경우 리베이스로 인해 force push된 브랜치를 rebase하면 된다.
- 요약: push하기 전에 로컬에 있는 변경사항을 rebase하여 작업 이력을 정돈하되, 이미 push된 것은 rebase하지 마라.