# 7.15 요약
7장에서는 깃의 다양한 기능을 다소 심층적으로 살펴보았다.

## 7장 1절
하나의 커밋 혹은 여러개의 커밋을 지칭하는 문법에 대해 배웠다.

- ^와 ~의 차이에 대해 알았다.
- ..과 ...의 뜻에 대해 알았다.

## 7장 2절
`git add` 명령어에 `-i` 옵션을 주어 대화식으로 작업할 수 있다는 것을 알았다.

- what now 프롬프트에 원하는 작업을 지정 후 작업한다.
- 작업이 다 끝났으면 아무것도 치지 않은 상태에서 엔터를 누르면 작업이 끝난다.
- 부분적으로 stage, unstage, discard, stash를 할 수 있음을 알았다.

## 7장 3절
`git stash` 명령어와 `git clean` 명령어에 대해 알았다.

- stash는 마무리하지 못한 작업을 임시로 저장해놓고자 할 때 유용하다.
- 몇 개의 subcommand들이 있으며, 여러가지 옵션을 줘서 동작을 변화시킬 수 있다.
- clean은 작업영역에서 tracked되지 않은 파일들을 지우기 위한 명령어이다.
   - `git rm`과는 쓰임새가 다르다.
- `-f` 옵션이 없으면 파일을 지우지 않으며, `-n`으로 dry-run 및 `-i`로 대화식 작업도 가능하다.

## 7장 4절
태그와 커밋에 GPG 키로 서명하는 방법을 배웠다.

- 서명을 하려면 먼저 GPG 키가 가지고 있어야 한다.
- 태그에 서명하려면 `-s` 옵션을, 태그를 검증하려면 `-v` 옵션을 사용한다.
   - 단, 검증시 해당 키가 내 keyring에 있어야 한다.
- 커밋(머지커밋 포함)에 서명하려면 `-S` 옵션을 `git commit` 혹은 `git merge`에 전달한다.
- 병합 시, `--verify-signature` 옵션으로 서명이 없거나 유효하지 않은 커밋이 있다면 병합을 거부시킬 수 있다.

## 7장 5절
`git grep` 명령어와 `git log` 에 대해 배웠다.

- 둘 다 탐색이라는 공통점이 있으나, grep은 "어디"에 있는지를, log는 "언제, 어떻게" 있었는지를 알아보는데 도움이 된다.
- grep은 작업 영역이나 임의의 tree에서 문자열이나 정규표현식을 탐색한다.
- 출력의 형태를 바꾸는 몇 개의 옵션들이 있으며, 특정 패턴을 지정함으로써 출력을 제한할 수 있다.
- log는 지난 장에서도 배운 바 있듯이 여러가지 옵션을 줘서 출력을 제한할 수 있다.
- 주목할만한 것으로는 `-L` 옵션으로, 특정 함수의 변화과정을 확인할 수 있다.

## 7장 6절
`git rebase -i`를 통해 커밋 이력을 재작성하는 방법에 대해 배웠으며, `git filter-branch`라는 명령어의 존재에 대해서도 알게 되었다.

- 인터랙티브 리베이스를 하려면, 내가 수정하려는 커밋 중 가장 오래된 커밋의 부모 커밋을 인자로 제공한다.
- 인터랙티브 리베이스로, 이런 것들을 할 수 있다:
   - 다수의 커밋 메시지를 변경할 수 있다.
   - 커밋의 순서를 변경할 수 있다.
   - 다수의 커밋을 하나의 커밋으로 합칠 수 있다.
   - 하나의 커밋을 다수의 커밋으로 쪼갤 수 있다.
   - 커밋을 삭제할 수 있다.
- filter-branch는 강력하지만 내가 뭘 하고 있는지 잘 알고 사용하기가 어려운 것 같다. 또, 성능에 문제가 있어 사용이 비권장된다는 것을 알았다.

## 7장 7절
3개의 tree의 관점에서, `git reset`과 `git checkout`의 작동방식을 공부하였다.

- 두 명령어의 공통점이라고 한다면...
   - `-- path`를 지정했을 때와 지정하지 않았을 때의 행동이 다르다는 것이 있다.
   - 작업영역을 날릴 수 있는 사용방식이 있다.
      - reset의 경우 `--hard`
      - checkout의 경우 `-- path`
- reset의 사용방식 중 하나는 mode를 지정하는 것으로, `git reset [<mode>] [<commit>]`의 형태로 쓴다.
   - mode에는 여러가지 종류가 있으나 책에서 다룬 것은 `--soft`, `--mixed`, `--hard`의 3종류다. mixed가 기본값이다.
   - commit의 기본값은 HEAD이다.
   - soft는 HEAD가 가리키는 브랜치를 commit으로 옮긴다.
   - mixed는 soft에 더해 index를 HEAD와 같게 만든다.
   - hard는 mixed에 더해 작업영역을 index와 같게 만든다.
- reset의 다른 사용방식은 path를 지정하는 것으로, `git reset [<commit>] [--] <file-or-path>`의 형태로 쓴다.
   - commit의 기본값은 HEAD이다.
   - 위 명령의 의미는 commit에서 특정 파일을 꺼내서 index에 갱신하라는 뜻이다.
- checkout의 사용방식 중 하나로는 `git checkout <branch>`가 있다.
   - HEAD 자체를 branch로 이동시킨다.
   - 작업영역을 함부로 날리지 않는 것으로 보인다.
- checkout의 다른 사용방식으로는 `git checkout [<commit>] [--] <file-or-path>`가 있다.
   - HEAD를 움직이지 않는다.
   - commit이 지정되지 않았을 경우 index에서 지정된 파일을 꺼내 작업영역에 덮어씌운다.
   - commit이 지정된 경우 해당 commit에서 파일을 꺼내 index와 작업영역에 덮어씌운다.
- 요약:
   - reset과 checkout 모두 path의 지정 여부에 따라 커밋 수준에서 작동하는지, 파일 수준에서 작동하는지가 달라진다.
   - 작업영역을 날리는 명령의 경우 생각하고 사용하도록 하자.

## 7장 8절
병합에 관련된 여러가지 사항들을 배웠다. 주목할만한 것으로는 파일을 수동으로 병합하는 것이 있었고, subtree라는 개념에 대해서도 알게 되었다. 또, combined diff format이라는 게 무엇인지도 알았다.

- 충돌이 일어날 수 있는 병합을 진행하기 전에 작업영역을 깨끗하게 해 놓는 것이 중요하다. (임시 브랜치에 커밋하거나 스태시하면 된다.)
- 병합 충돌이 일어나기 전으로 되돌아가려면 `git merge --abort` 혹은 하드리셋하면 된다. 단, 하드리셋이 의미하는 바는 이전 절에서 배웠다.
- `git merge-file <2> <1> <3>`으로 파일을 수동 병합할 수 있다.
   - 여기서 1, 2, 3은 각각 공통 조상에 위치한 파일, 내가 위치한 브랜치의 파일, 병합하려는 브랜치의 파일을 의미한다.
   - 병합 충돌 상태에서 `git show :<n>:<file>` 로 얻을 수 있다.
- 파일을 충돌이 난 상황으로 다시 되돌리고 싶으면 `git checkout --conflict <file>` 명령으로 가능하다.
- 충돌시 어느 한쪽을 취하려면 `git checkout (--ours|--theirs)` 명령으로 가능하다.
- `git log`를 통해 충돌의 맥락을 파악하자.
   - `--left-right` 옵션으로 커밋이 어느 브랜치에 속하는지 확인하자.
   - 커밋 범위인 `HEAD...MERGE_HEAD`를 전달해서 각 브랜치에 속한 고유한 커밋들을 확인하자.
   - `--merge` 옵션으로 충돌이 난 파일을 건드린 커밋만을 확인하자.
- combined diff format에서는 줄의 시작에 2개의 열이 생긴다.
   - 첫번째 열은 이 줄이 ours와 작업영역 사이에서 다른지를 나타낸다.
   - 두번째 열은 이 줄이 theirs와 작업영역 사이에서 다른지를 나타낸다.
- 병합을 되돌리려면 직전 HEAD (즉 HEAD^) 로 하드리셋하거나 `git revert -m 1 HEAD`할 수 있다.
   - `-m 1` 이라는 옵션의 뜻은 첫번째 부모 (병합할때 위치하고 있었던 브랜치) 의 변경사항을 유지하겠다는 것이다.
   - revert시 주의할 점은 병합을 되돌려도, 되돌리기 이전의 병합 커밋이 여전히 커밋 이력에 남아있다는 것이다.
   - 이것이 시사하는 바는 revert 후 재병합하려고 하면 최신상태여서 병합이 안된다는 것이다.
   - 이 문제를 해결하는 방법은 revert한 커밋을 다시 revert하는 것이다.
- recursive 병합 전략에 `-Xours` 혹은 `-Xtheirs` 옵션을 지정하면 충돌이 난 부분에 대해서는 선호하도록 명시된 쪽을 따르고, 충돌이 나지 않은 부분은 정상적으로 병합된다.
   - 최신 버전의 깃에서는 ort가 recursive 대신 기본 전략이 된 것으로 보인다.
- ours 병합 전략은 선호하지 않는 쪽을 완전히 배제하는 병합 전략이다. 즉, 병합 커밋은 생기나 비선호 브랜치의 내용이 포함되지 않게 된다.
- subtree라는 것은 잘 이해하지는 못했으나, 하나의 프로젝트 안에 두 개의 프로젝트가 들어있고 한 프로젝트가 다른 프로젝트의 subdirectory에 연결되어 있는 것을 이르는 말인 것으로 보인다.
   - 매뉴얼을 대충 보니까 ort의 옵션에도 subtree가 있고, 별도의 병합 전략으로도 subtree가 있는 듯하다.
   - subtree 관련된 작업을 하는데 사용되는 명령어로는 `git read-tree`, `git diff-tree`가 있는 듯하다.

## 7장 9절
`git rerere` 명령어에 대해서 배웠다.

- 병합 충돌이 발생했을 때의 "이미지"와 내가 수동으로 병합 충돌을 해결한 뒤의 "이미지"를 저장해둔 뒤, 다음에 같은 파일에서 같은 충돌이 나면 자동으로 충돌을 해결하는 기능이다.
- 이 기능을 사용하려면 우선 `rerere.enabled` 를 true로 지정해서 활성화해야 한다.

## 7장 10절
`git blame`과 `git bisect` 명령어를 배웠다.

- blame은 파일에서 어떤 줄을 어떤 커밋이 가장 마지막으로 수정했는지를 보여준다.
- `-L` 옵션으로 주어서 출력의 범위를 특정 함수나, 한 줄에서 다른 줄 사이까지로 제한할 수 있다.
- bisect는 무엇이 어디에서 잘못되었는지를 색출하는데 유용한 명령어로, 커밋 이력에 대해서 이진탐색을 수행한다.
- 테스트 스크립트를 통해 탐색과정을 자동화할 수 있다.

## 7장 11절
`git submodule`에 대해 배웠다.

- 하나의 프로젝트에서 다른 프로젝트를 사용한다는 점으로부터, 서브모듈은 위에서 언급한 subtree와 공통점이 있다.
- 그러나 서브모듈이 subtree와 다른 점은 "깃 저장소"가 다른 깃 저장소의 subdirectory에 위치한다는 것 같다.
- 서브모듈을 가지는 메인 프로젝트를 superproject라고 칭하는 듯하다.
- `.gitmodules` 파일에 서브모듈에 관련된 정보(url)가 들어있다.
- 서브모듈을 추가하려면 `git submodule add` 명령어를 사용한 후 `git push`를 하면 되는 듯하다.
- 전반적으로, `--recurse-submodules` 옵션을 주는 것이 서브모듈의 사용을 수월하게 만들어 주는 것으로 보인다.
   - 이 옵션을 지원하는 명령어들이 있다.
   - 이 명령어들에서 이 옵션을 항상 자동으로 사용하려면 `submodule.recurse`를 true로 지정한다.
   - 단, `git clone`은 예외이다.
- 서브모듈을 가지고 있는 프로젝트를 clone하려면, `git clone --recurse-submodules`를 실행한다.
   - 만약 깜빡했다면 `git submodule update --init --recursive`를 해주면 된다.
- 서브모듈의 원격에서 변경사항을 내려받으려면, `git submodule update --remote` 해주면 된다.
   - checkout이 update되고, detached HEAD 상태가 되는 것 같다.
   - 내려받은 후 (당연히 superproject에서겠지?) 커밋을 하면, 다른 사람들이 (superproject를 내려받았을 때도?) 이 서브모듈의 버전으로 lock된다는 것 같다.
- superproject의 원격에서 변경사항을 내려받으려면 `git pull --recurse-submodules`를 하면 된다.
- 서브모듈에서 작업하려면 `cd`로 서브모듈 내로 이동해서 `git checkout <branch>` 해야 하는 것 같다.
   - (superproject에서) 업데이트를 받을 때 `git submodule update --remote (--merge|--rebase)` 해줘야되는 듯하다.
- 서브모듈의 변경사항을 push하려면 `git push --recurse-submodules=(check|on-demand)` 해야 함
   - check로 지정시 push가 되어 있지 않은 서브모듈이 있다면 push에 실패한다.
   - on-demand로 지정시 한번에 다 push된다.
- 서브모듈에서 병합시 충돌이 났다면 충돌이 난 upstream의 sha-1을 획득 후, 해당 서브모듈 내에서 해당 sha-1에 브랜치를 만들고 `git merge`를 진행해 충돌을 해결하면 된다.
- `git submodule foreach <cmd>`를 통해 일괄적으로 원하는 명령을 수행할 수 있다.
- 서브모듈을 추가한 브랜치와 그렇지 않은 브랜치 사이를 이동하려면 `git checkout --recurse-submodules`를 해야 하는 듯하다.

## 7장 12절
`git bundle`에 대해 배웠다.

- 깃 데이터를 전달하는 방법 중 하나이다.
- 통상적으로는 git push로 전송될 깃 데이터를 하나의 바이너리 파일로 만든다.
- 포함시키고자 하는 브랜치나 커밋 범위를 지정할 수 있다.
- `verify` 및 `list-heads` subcommand를 통해 번들 파일을 검사할 수 있다.
- 번들 파일에 대해 clone, fetch, pull할 수 있다.

## 7장 13절
`git replace`에 대해 배웠다.

- 깃의 object DB에 있는 object 변경불가이나, 한 object를 다른 object로 대체한 것처럼 보이게 하는 방법은 있음
- 커밋 p를 커밋 q로 대체한 경우, sha-1는 p의 것을 따르나 내용물은 q의 것을 따름
- 대체하더라도 blame이나 bisect 등의 명령어들은 정상적으로 작동함
- 대체한 기록이 refs/replace에 남으므로, 내가 대체한 것을 타인과 공유 가능

## 7장 14절
`git credential` 명령어와 자격증명 헬퍼 프로그램에 대해 알아보았다.

- 자격증명 헬퍼를 통해 매번 인증하는 번거로움을 덜 수 있는 것으로 보임
- `credential.helper` 항목에 헬퍼를 지정할 수 있으며, 여러 개의 헬퍼를 등록할 수 있다.
- git에서 제공하는 헬퍼로는 store와 cache가 있다
- git이 자격증명을 질의할때는 등록된 순서대로 순차적으로 질의한다.
- git이 자격증명을 저장할때는 모든 헬퍼에 값을 보낸다.
- `git credential`은 자격증명을 관리하는 root 명령어로 subcommand를 인자로 받고 stdin으로 "credential description"을 취한다.
- credential description은 한 줄마다 필드=값 문법으로 작성되고, 맨 마지막 줄에는 빈 줄을 배치하는 것으로 보인다.
- 헬퍼는 별도의 프로그램이며 credential과 동일한 stdin/stdout 규칙을 사용하나 헬퍼에 지정되는 subcommand가 다르다.
- 내 필요에 맞는 헬퍼 프로그램을 직접 만들어서 쓸 수도 있다.

## 7장 15절
7장은 긴 장이었지만 많은 것을 알 수 있었다.

- 파일의 일부분에 대해서만 원하는 작업을 할 수 있게 되었다.
- 커밋 이력을 좀 더 자세하게 조작할 수 있게 되었다.
- 버그가 발생했을 때 언제, 어디서, 누구에 의해 버그가 발생했는지 알 수 있게 되었다.
- 서브모듈의 사용방법을 알았다.
- 좀 더 자신감있게 깃을 사용할 수 있게 되었다.

## 영어 공부
- accommodate: (공간/의견을) 수용하다
