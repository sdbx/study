# 5.2 프로젝트에 기여하기

## 학습목표
- 커밋을 그 뜻이 분명하도록 작성하는 방법을 생각해본다.
- 다양한 환경에서 협업하는 방법을 배운다.
- 현실의 환경에 실제적으로 응용할 수 있도록 한다.

## 개요
프로젝트에 기여하는 방법을 한 문장으로 설명하기가 어려운 이유는 여러가지 변수들이 있기 때문이다.
- 활동하는 기여자 수
   - 개발자 수가 많을수록 내 코드가 깨끗하게 적용되는지, 쉽게 병합되는지 확신하기 어려워짐
   - 어떻게 내 코드를 일관적으로 유지하고 커밋이 유효하도록 둘 것인가?
- 선택된 작업흐름
   - (중앙집중식) 모든 개발자가 mainline에 동등한 쓰기 권한을 가지는가?
   - 프로젝트에 메인테이너나 통합관리자가 있어서 모든 패치를 검수하는가?
   - (계층적) 먼저 중간관리자에게 점검을 받는 구조인가?
   - 내 패치를 동료가 검수하는가? 나도 동료의 패치를 검수하는가?
- 나에게 주어진 권한(commit access)
   - 쓰기 권한이 나에게 있는가?
   - 없다면, 이 프로젝트가 선호하는 기여 방식이 있는가? 혹은 정책(policy)이 있는가?
   - 한번에 얼마나 많이 기여하는가? / 어떤 빈도로 기여하는가?
- 별도의 기여 방법

## 커밋을 알기 쉽게 작성하는 방법
### 커밋
- 불필요한 공백이 없어야 한다. 이를 감지하려면 **커밋하기 전에** `git diff --check` 을 실행한다.
- 각각의 커밋을 **논리적으로 구분되는 변경사항의 집합(changeset)**으로 만드려고 노력한다.
- 변경사항을 **소화할 수 있는 분량**으로 만들어라. 즉, 여러가지 변경사항을 며칠동안 작업한 후 하나의 거대한 커밋으로 올리지 마라.
   - 커밋을 중간중간 해가면서 작업하지 않았더라도, 마지막에 분할해서 올려라.
   - 같은 파일에 별도의 변경사항이 있다면 `git add --patch` 를 사용해 부분적으로 파일을 stage할 수 있다.
- 위와 같은 접근 방식을 사용하면 변경사항 중 일부만을 취하거나 버릴 때, 커밋 이력을 재작성해서 깨끗하고 이해하기 쉽게 만들 때 도움이 된다.

### 커밋 메시지
- 공을 들인 커밋 메시지를 작성하는 습관은 좋음.
- 커밋 메시지 작성 예시:
   - 첫번째 줄은 50글자를 넘어가지 않고 변경사항을 간결하게 묘사한다. 대문자로 시작한다.
   - 더 자세한 설명이 필요하다면,
      - 그 뒤로 공백 줄을 하나 배치
      - 그 뒤로 더욱 상세한 설명을 한다. (이 변경을 만든 동기, 이전 동작과의 차이 등)
      - 72글자 정도로 wrap한다.
      - 여러개의 문단으로 작성 가능
      - bullet point 사용 가능 (보통 -이나 *문자 사용)
         - bullet과 내용 사이에 공백 하나
         - bullet과 bullet 사이에 공백줄
         - hanging indent 사용
   - 명령법으로 작성하라.

## 비공개인 소규모 팀
- 비공개라는 말의 뜻 = closed-source이다.
- 이러한 환경에서는 중앙집중식 작업흐름을 사용하는 동시에 git의 이점을 활용 가능함 (오프라인 커밋, 단순한 브랜칭/머징)
- 한사람이 푸쉬한다음에 다른사람이 푸쉬하려고 하면 오류가 나옴. 이럴때는 마지막에 푸쉬하려는 사람이 먼저 fetch+merge 해야 함.
- 일반적인 작업 흐름:
   1. 토픽 브랜치에서 작업
   2. 준비가 되면 내 master 브랜치에 병합
   3. 만약 origin/master가 변경되었다면 fetch와 (내 master로) merge
   4. 내 master 브랜치를 서버에 push

### oldref..newref
`<oldref>..<newref> fromref -> toref`
- oldref: old reference => 해시 7자리
- newref: new reference => 해시 7자리
- fromref: 푸시되는 로컬 레퍼런스의 이름
- toref: 업데이트되는 원격 레퍼런스의 이름

### git log에서 커밋 filter하기
`git log --no-merges mybranch..origin/master` 라는 말의 뜻: origin/master 브랜치에만 있고 mybranch에는 없는 커밋을 보여줘

branch..branch의 자세한 의미는 7장 1절 (commit range) 에서 설명됨

## 비공개로 관리되는 팀
- 작은 그룹이 기능에 대해 협업하고, 후에 그 팀 기반 기여가 다른 사람에 의해 통합된다.
- 일종의 integration-manager workflow => 개별 그룹의 작업이 특정 인원에 의해서만 통합되고 메인 repo의 master 브랜치는 그 인원에 의해서만 갱신된다.
- 팀 기반 브랜치에서 작업된 모든 작업물이 추후에 통합자에 의해 pull됨
- 즉, 다수의 팀이 평행하게 작업하고, 나중에 merge 가능
- subgroup은 remote branch를 통해 작업하므로, 꼭 전체 팀을 연관시키거나 지연시켜야 하는 것은 아님

### refspec
- `git push -u origin branchA:branchB`
- `<src>:<dst>` 를 **refspec**이라고 하며 10장 5절에서 다루는 주제
- `-u` => `--set-upstream` 의 약자로, 쉬운 push과 pull을 위해 브랜치를 환경설정함

## 포크된 공개 프로젝트
- 프로젝트의 브랜치를 직접 업데이트할 권한 없음
- 따라서 내 작업을 메인테이너에게 보낼 수단이 필요
- fork 기능을 지원하는 git host 사이트가 한 방법
- 많은 메인테이너가 이 방식의 기여를 기대
- 다음의 흐름을 따름:
   1. 메인 repo를 clone함
   2. 토픽 브랜치 생성
   3. 패치(들)을 만든다 (커밋)
   4. `rebase -i`를 사용해 작업물을 하나의 커밋으로 squash하거나, 패치의 순서를 바꿀 수 있음
   5. 원본 repo를 fork함
   6. fork된 repo를 remote로 등록
   7. 토픽 브랜치를 fork에 push한다 (메모: 내 master 브랜치에 merge할 필요 없음. 하면 번거로워짐)
   8. 원본 repo의 메인테이너에게 그들이 merge해주기를 바라는 work가 있다고 알려주기 (이것을 두고 **pull request**라고 한다)
      - 웹사이트를 통해 이러한 요청을 만들수도 있고
      - `git request-pull` 명령어의 결과물을 메인테이너에게 이메일보내도 된다
- 내가 메인테이너가 아닌 프로젝트 상에서는,
   - master 브랜치가 항상 origin/master를 track하게 하는 것이 낫다
   - 작업은 topic 브랜치에서 한다 (만약 거절되면 쉽게 폐기 가능)
   - 작업의 주제를 토픽 브랜치 내로 분리하면 리베이스하기도 쉬움
   - 새로운 작업은 새로운 토픽 브랜치에서 (기존에 푸쉬했던 토픽 브랜치 계속 사용 X) => origin/master에서 다시 시작

### git request-pull
`git request-pull <base-branch> <fork-url>`
- base-branch: 내 topic branch가 pull into되기를 바라는 브랜치
- fork-url: 메인테이너가 pull from하기를 바라는 git repo url

### git merge --squash <branch>
`--squash` 옵션은 branch에 있는 모든 작업을 취해 하나의 changeset으로 squash한다. 즉, 실제로는 merge commit을 생성하지 않으면서, 진짜 merge가 일어난 것과 같은 repo state를 만든다.

참고로, 일반적인 merge process의 경우 `--no-commit` 옵션을 주면 merge commit을 지연시킬 수 있다고 한다.

## 이메일을 통해 공개 프로젝트에 기여하기
- 개발자 메일링 리스트를 통해 패치를 받는 프로젝트들이 있음.
- 작업흐름은 위의 "포크된 공개 프로젝트"와 유사함. 차이점은 어떻게 패치를 보낼 것인가임.
- 커밋의 이메일 버전을 만든 뒤 개발자 메일링 리스트에 이메일을 보냄.
- `git format-patch` 를 사용하면 mbox-formatted file을 생성한다.
   - 각 커밋을 이메일 메시지로 만듦
   - 커밋 메시지 첫줄 = 제목
   - 나머지 + 이 커밋이 도입한 패치 = 내용
   - `-M` 옵션은 rename을 감지함.
   - `---` 줄과 `diff --git` 줄 사이에 적은 내용은 patching process에서 무시되지만 개발자는 읽기 가능
- 이메일을 보내려면 이걸 복사해서 이메일 프로그램에 넣든지 cmd 프로그램을 통해 전송 가능
- 직접 복사하는 것은 formatting issue가 있을 수 있음.
- IMAP을 통해 올바르게 format된 패치를 보내는 도구를 git이 제공함
- ~/.gitconfig 파일에 imap 섹션을 구성한다
- `git imap-send` 후 Drafts 폴더에 가서 To 필드를 메일링 리스트로 수정, 메인테이너 등 다른 책임자를 CC 가능, 전송하면 끝
- SMTP 서버를 통해서도 전송 가능
- ~/.gitconfig 파일에 sendemail 섹션 구성
- `git send-email`

## 영어 공부
- at a time: 한번에, 따로따로
- concisely: 간결하게
- impede: 지연시키다
- happen to: 우연히 ~하다
- cc = carbon copy (추가적으로 이메일 보내는것)