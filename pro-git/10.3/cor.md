# 10.3 깃 레퍼런스

## 학습목표
- 레퍼런스의 개념을 이해한다.

## 들어가며
- 긴 SHA-1에 간단한 이름을 붙여서 파일에 저장해두면 사용하기 쉬울 것
- 이러한 간단한 이름들을 두고 **reference** 혹은 **ref**라고 함
- 레퍼런스들은 `.git/refs` 디렉토리 아래에 저장됨
- 레퍼런스 파일을 직접 edit하는 것은 권장되지 않음
- `git update-ref`를 사용해 안전하게 레퍼런스를 생성/업데이트할 수 있음
   - 예시: `~ refs/head/main <40자리>`
- 일반 브랜치 (커밋을 가리키는) 는 `refs/heads` 디렉토리 아래에 보관되는 듯

## HEAD 레퍼런스
- `git branch <branch>`를 했을때 깃이 최신 커밋의 SHA-1을 아는 방법 => HEAD 파일
- 보통 HEAD 파일은 내가 현재 위치한 브랜치에 대한 **symbolic reference**
- symbolic ref라는 말의 뜻은 일반적인 ref와는 다르게, **다른 레퍼런스를 가리키는 포인터를 포함하고 있다는 뜻**임
- 단, 태그, 커밋, 원격브랜치로 checkout하면 HEAD가 깃 객체의 SHA-1을 들고있게 되며 이를 **detached HEAD** 상태라고 함
- git commit시 새로 생기는 커밋의 부모커밋은 HEAD 내에 있는 레퍼런스가 가리키고 있는 SHA-1 값이 됨
- `git symbolic-ref`를 통해 HEAD의 값을 조회/수정할 수 있음

## 태그
- blob, tree, commit 외에도 깃 오브젝트 유형이 하나 더 있음 => tag
- 태그는 여러가지 정보를 들고있다는 점에서 커밋과 유사하지만 주요한 차이는 태그는 일반적으로 tree보다는 commit을 가리킨다는 것임
- 비유하자면 태그는 브랜치 레퍼런스같은 것인데 절대 움직이지 않음
- `git update-ref refs/tags/v1.0`과 같은 식으로 경량태그 생성 가능
- 그러나 주석태그의 경우, 태그 오브젝트가 생성되며 그 오브젝트를 가리키는 레퍼런스를 작성함 (커밋을 직접적으로 가리키는게 아님)
- 태그가 꼭 커밋을 가리킬 필요는 없음. 임의의 깃 객체를 태그할 수 있음.
   - 예시로, 예전 장에서 소개됐던 프로젝트에 gpg 키를 blob으로 등록해두는 것

## 원격
- 원격 레퍼런스란 원격에 마지막으로 푸쉬한 값을 각 브랜치별로 `refs/remotes` 디렉토리에 저장해둔 것임
- 예를 들어 `refs/remotes/origin/master`라는 말의 뜻은 마지막으로 origin과 통신했을때 master에 있던 것이라는 의미임
- 원격 레퍼런스는 read-only로 여겨진다는 점에서 브랜치(즉, `refs/heads`)와는 주요하게 다름
- 원격 브랜치로 checkout할수는 있지만 HEAD가 원격브랜치를 symbolic reference하지는 않음
   - 그래서 commit해도 절대 원격브랜치는 절대 갱신 안됨
- 비유하자면 서버상에 브랜치들이 어디에 있었는지에 대해 마지막으로 알려진 상태를 나타내는 책갈피같은 것임
